#-----------------------------------------------------------------
# pycparser: func_defs.py
#
# Using pycparser for printing out all the functions defined in a
# C file.
#
# This is a simple example of traversing the AST generated by
# pycparser. Call it from the root directory of pycparser.
#
# Eli Bendersky [https://eli.thegreenplace.net/]
# License: BSD
#-----------------------------------------------------------------
from __future__ import print_function
import sys

# This is not required if you've installed pycparser into
# your site-packages/ with setup.py
sys.path.extend(['.', '..'])

from pycparser import c_ast, parse_file


# A simple visitor for FuncDef nodes that prints the names and
# locations of function definitions.
class FuncDefVisitor(c_ast.NodeVisitor):
    def visit_FuncDef(self, node):
        final_product = ""
        #static or not
        #print(node.decl)
        if bool(node.decl.storage):
            #print(node.decl.storage)
            #print(type(node.decl.storage))
            final_product += node.decl.storage[0] + " "
        #final_product += node.decl.storage
        #this logic looks at the function declaration
        if isinstance(node.decl.type.type, c_ast.PtrDecl):
            #print(node.decl.type.type.type.type.names)
            #print("*")
            #print(node.decl.type.type.type.declname)
            final_product += node.decl.type.type.type.type.names[0] + " *" + node.decl.type.type.type.declname
        else:
            #print(node.decl.type.type.type.names)
            #print(node.decl.type.type.declname)
            final_product += node.decl.type.type.type.names[0] + " " + node.decl.type.type.declname
        #this logic looks at ALL arguments passed in function declaration
        final_product += "("
        if node.decl.type.args is not None:
            for argument in range(len(node.decl.type.args.params)):
                #print(node.decl.type.args.params[argument].type)
                if isinstance(node.decl.type.args.params[argument].type, c_ast.PtrDecl):
                    #print(node.decl.type.args.params[argument].type.type.type.names)
                    if isinstance(node.decl.type.args.params[argument].type.type.type, c_ast.TypeDecl):
                        final_product += node.decl.type.args.params[argument].type.type.type.type.names[0] + " *"
                    else:
                        final_product += node.decl.type.args.params[argument].type.type.type.names[0] + " " + "*"
                    #print("*")
                    if len(node.decl.type.args.params[argument].type.quals) != 0:
                        final_product += "* " + node.decl.type.args.params[argument].type.quals[0] + " "
                    if len(node.decl.type.args.params[argument].type.type.quals) != 0:
                        final_product += node.decl.type.args.params[argument].type.type.quals[0] + " * "
                else: 
                    #print(node.decl.type.args.params[argument].type.type.names)
                    final_product +=  node.decl.type.args.params[argument].type.type.names[0] + " "
                #print(node.decl.type.args.params[argument].name)
                if node.decl.type.args.params[argument].name is not None:
                    final_product += node.decl.type.args.params[argument].name
                if isinstance(node.decl.type.args.params[argument].type.type, c_ast.FuncDecl):
                    final_product += node.decl.type.args.params[argument].type.type.type.type.names[0] + " "
                    final_product += "(*" +  node.decl.type.args.params[argument].name + ")("
                    for nested_argument in range(len(node.decl.type.args.params[argument].type.type.args.params)):
                        if isinstance(node.decl.type.args.params[argument].type.type.args.params[nested_argument].type,  c_ast.PtrDecl):
                            final_product += node.decl.type.args.params[argument].type.type.args.params[nested_argument].type.type.type.names[0] + "* "
                        else:
                            final_product += node.decl.type.args.params[argument].type.type.args.params[nested_argument].type.type.names[0] + " "
                            if node.decl.type.args.params[argument].type.type.args.params[nested_argument].name is not None:
                                    final_product += node.decl.type.args.params[argument].type.type.args.params[nested_argument].name
                    final_product += ")"
                if argument < len(node.decl.type.args.params):
                    final_product += ", "
        final_product += ")"
        #print(node.decl.type.type.type.type.names)
        #print(final_product)
        print('%s at %s' % (final_product, node.decl.coord))


def show_func_defs(filename):
    # Note that cpp is used. Provide a path to your own cpp or
    # make sure one exists in PATH.
    ast = parse_file(filename, use_cpp=True,
                     cpp_args=r'-Iutils/fake_libc_include')

    v = FuncDefVisitor()
    v.visit(ast)


if __name__ == "__main__":
    if len(sys.argv) > 1:
        filename  = sys.argv[1]
    else:
        filename = 'examples/c_files/memmgr.c'

    show_func_defs(filename)
